var o=class{constructor(t){this.app=t}panTo(t,s){this.app.sendCommand("panTo",{lat:t,lng:s})}panToEntity(t,s){this.app.sendCommand("panToEntity",{type:t,id:s})}};var l=class{constructor(){this.listener={},this.listenerId=0}on(t,s,i,e){if(typeof s!="function")throw new Error(`no function for ${t}`);return this.listenerId++,this.listener[t]||(this.listener[t]=[]),this.listener[t].push({eventName:t,fn:s,context:i,order:e,id:this.listenerId}),this.listener[t].sort((r,c)=>r.order==c.order?0:r.order>c.order?1:-1),this.listenerId}off(t,s,i){if(!!this.listener[t]){for(var e=this.listener[t].length;e--;)this.listener[t][e].fn===s&&this.listener[t][e].context===i&&this.listener[t].splice(e,1);this.listener[t].length===0&&delete this.listener[t]}}removeListenerById(t,s){if(!this.listener[t])throw new Error("No listener registered for eventname "+t);var i=!1;if(this.listener[t]=this.listener[t].filter(e=>e.id===s?(i=!0,!1):!0),!i)throw new Error(`Failed to find listener with id ${s} for event ${t}`)}emit(t){if(!this.listener[t])return;let s=Array.prototype.slice.call(arguments,1);for(var i=null,e=0;this.listener[t]&&this.listener[t][e];){if(i=this.listener[t][e],this.listener[t][e].fn.apply(this.listener[t][e].context,s)===!1)return;this.listener[t]&&this.listener[t][e]===i&&e++}}hasListeners(t){return this.listener[t]&&this.listener[t].length>0}};var h=class extends l{constructor(t){super(),this.app=t}select(t,s){this.app.sendCommand("select",{id:t,type:s})}unselect(){this.app.sendCommand("select",{id:null,type:null})}async get(){return this.app.sendRequest("getSelection",null)}};var d=class{constructor(t){this.app=t}setSize(t,s){this.app.sendCommand("setAppWindowSize",{width:t,height:s})}close(){this.app.sendCommand("closeAppWindow")}};var p={selectionChange(n,t){n.selection.emit("change",t.type,t.id)}};var a=class{constructor(){this.map=new o(this),this.selection=new h(this),this.appWindow=new d(this),this.pendingRequests={},window.addEventListener("message",this.handleMessage.bind(this))}handleMessage(t){let{command:s,data:i,correlationId:e}=t.data;if(e){let r=this.pendingRequests[e];r&&(console.log("resolving",i),r(i),delete this.pendingRequests[e])}!s||p[s]&&p[s](this,i)}sendCommand(t,s){(window.parent||window.opener).postMessage({command:t,data:s},"*")}async sendRequest(t,s){let i=window.parent||window.opener,e=Math.random().toString(36).substring(2,15);return new Promise(r=>{this.pendingRequests[e]=r,i.postMessage({command:t,data:s,correlationId:e},"*")})}};export{a as default};
