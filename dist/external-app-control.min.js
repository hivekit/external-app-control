var o=class{constructor(t){this.app=t}panTo(t,s){this.app.sendCommand("panTo",{lat:t,lng:s})}panToEntity(t,s){this.app.sendCommand("panToEntity",{type:t,id:s})}};var l=class{constructor(){this.listener={},this.listenerId=0}on(t,s,i,e){if(typeof s!="function")throw new Error(`no function for ${t}`);return this.listenerId++,this.listener[t]||(this.listener[t]=[]),this.listener[t].push({eventName:t,fn:s,context:i,order:e,id:this.listenerId}),this.listener[t].sort((n,u)=>n.order==u.order?0:n.order>u.order?1:-1),this.listenerId}off(t,s,i){if(!!this.listener[t]){for(var e=this.listener[t].length;e--;)this.listener[t][e].fn===s&&this.listener[t][e].context===i&&this.listener[t].splice(e,1);this.listener[t].length===0&&delete this.listener[t]}}removeListenerById(t,s){if(!this.listener[t])throw new Error("No listener registered for eventname "+t);var i=!1;if(this.listener[t]=this.listener[t].filter(e=>e.id===s?(i=!0,!1):!0),!i)throw new Error(`Failed to find listener with id ${s} for event ${t}`)}emit(t){if(!this.listener[t])return;let s=Array.prototype.slice.call(arguments,1);for(var i=null,e=0;this.listener[t]&&this.listener[t][e];){if(i=this.listener[t][e],this.listener[t][e].fn.apply(this.listener[t][e].context,s)===!1)return;this.listener[t]&&this.listener[t][e]===i&&e++}}hasListeners(t){return this.listener[t]&&this.listener[t].length>0}};var h=class extends l{constructor(t){super(),this.app=t}select(t,s){this.app.sendCommand("select",{id:t,type:s})}unselect(){this.app.sendCommand("select",{id:null,type:null})}async get(){return this.app.sendRequest("getSelection",null)}};var d=class{constructor(t){this.app=t}setSize(t,s){this.app.sendCommand("setAppWindowSize",{width:t,height:s})}close(){this.app.sendCommand("closeAppWindow")}};var p={selectionChange(r,t){r.selection.emit("change",t.type,t.id)}};var a=class{constructor(){this.map=new o(this),this.selection=new h(this),this.appWindow=new d(this),this.pendingRequests={},window.addEventListener("message",this.handleMessage.bind(this))}handleMessage(t){let{command:s,data:i,correlationId:e}=t.data;if(e){let n=this.pendingRequests[e];n&&(console.log("resolving",i),n(i),delete this.pendingRequests[e])}!s||p[s]&&p[s](this,i)}getTarget(){return window.opener||window.parent}sendCommand(t,s){this.getTarget().postMessage({command:t,data:s},"*")}async sendRequest(t,s){let i=Math.random().toString(36).substring(2,15);return new Promise(e=>{this.pendingRequests[i]=e,this.getTarget().postMessage({command:t,data:s,correlationId:i},"*")})}};export{a as default};
